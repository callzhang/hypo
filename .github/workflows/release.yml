name: Release

on:
  push:
    tags:
      - 'v*'  # Triggers on tags like v0.2.2, v1.0.0, etc.
    branches:
      - 'test/**'  # Also trigger on test branches for debugging
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.2.2)'
        required: true
        type: string

jobs:
  build-android:
    name: Build Android APK
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'
      
      - name: Cache Android SDK
        uses: actions/cache@v4
        with:
          path: |
            ~/.android
          key: ${{ runner.os }}-android-sdk-${{ hashFiles('android/**/*.gradle*', 'android/**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-android-sdk-
      
      - name: Setup Android SDK
        uses: android-actions/setup-android@v3
      
      - name: Accept Android SDK Licenses
        run: |
          # Accept all Android SDK licenses
          mkdir -p "$ANDROID_HOME/licenses"
          echo "24333f8a63b6825ea9c5514f83c2829b004d1fee" > "$ANDROID_HOME/licenses/android-sdk-license"
          echo "84831b9409646a918e30573bab4c9c91346d8abd" > "$ANDROID_HOME/licenses/android-sdk-preview-license"
          echo "601085b94cd77f0b54ff86406957099ebe79c4d6" > "$ANDROID_HOME/licenses/android-googletv-license"
          echo "33b6a2b64607a11ce79713110d54f32d" > "$ANDROID_HOME/licenses/android-sdk-arm-dbt-license"
          echo "d975f751698a77b662f1254ddbeed3901e976f5a" > "$ANDROID_HOME/licenses/intel-android-extra-license"
          echo "8403addf88ab4874007e1c1e80a0025de956b318" > "$ANDROID_HOME/licenses/google-gdk-license"
          echo "601085b94cd77f0b54ff86406957099ebe79c4d6" > "$ANDROID_HOME/licenses/mips-android-sysimage-license"
      
      - name: Grant execute permission for gradlew
        run: chmod +x android/gradlew
      
      - name: Build Release APK
        id: build-apk
        working-directory: android
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          # Increase Gradle JVM memory for faster builds
          GRADLE_OPTS: -Xmx4096m -Dfile.encoding=UTF-8
        run: |
          echo "üöÄ Starting Android build at $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          START_TIME=$(date +%s)
          ./gradlew assembleRelease --stacktrace --build-cache
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "‚úÖ Build completed in ${DURATION} seconds"
          echo "duration=${DURATION}" >> $GITHUB_OUTPUT
      
      - name: Build time summary
        if: always()
        run: |
          if [ -n "${{ steps.build-apk.outputs.duration }}" ]; then
            echo "### ‚è±Ô∏è Android Build Time" >> $GITHUB_STEP_SUMMARY
            echo "Build completed in **${{ steps.build-apk.outputs.duration }} seconds**" >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Upload Release APK
        uses: actions/upload-artifact@v4
        with:
          name: android-release-apk
          path: android/app/build/outputs/apk/release/app-release.apk
          # Optimize retention: shorter for test branches, longer for releases
          retention-days: ${{ contains(github.ref, 'refs/heads/test/') && '7' || '30' }}
          compression-level: 6

  build-macos:
    name: Build macOS App
    runs-on: macos-14
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python (for icon generation)
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      
      - name: Install Python dependencies
        run: pip install Pillow
      
      - name: Build macOS App
        working-directory: macos
        run: |
          set -e
          BINARY_NAME="HypoMenuBar"
          
          # Build the Swift package
          echo "Building Swift package..."
          swift build -c release
          
          # Create app bundle structure if it doesn't exist
          if [ ! -d "HypoApp.app" ]; then
            echo "Creating app bundle structure..."
            mkdir -p HypoApp.app/Contents/MacOS
            mkdir -p HypoApp.app/Contents/Resources
          fi
          
          # Find the built binary (product name is HypoMenuBar, target is HypoMenuBarApp)
          echo "Looking for built binary..."
          BUILT_BINARY=""
          
          # First, try the expected location (product name)
          if [ -f ".build/release/$BINARY_NAME" ]; then
            BUILT_BINARY=".build/release/$BINARY_NAME"
            echo "Found: $BUILT_BINARY"
          # Fallback: try target name
          elif [ -f ".build/release/HypoMenuBarApp" ]; then
            BUILT_BINARY=".build/release/HypoMenuBarApp"
            echo "Found: $BUILT_BINARY"
          # Fallback: search for any executable with MenuBar in name
          else
            BUILT_BINARY=$(find .build/release -name "*MenuBar*" -type f -executable 2>/dev/null | head -1)
            if [ -n "$BUILT_BINARY" ]; then
              echo "Found: $BUILT_BINARY"
            fi
          fi
          
          # Last resort: find any executable in release directory
          if [ -z "$BUILT_BINARY" ]; then
            echo "Error: Binary not found. Searching for any executables..."
            echo "Available files in .build/release:"
            find .build/release -type f 2>/dev/null | head -10 || echo "No .build/release directory found"
            echo "Available executables in .build:"
            find .build -type f -executable 2>/dev/null | head -10 || echo "No executables found"
            BUILT_BINARY=$(find .build/release -type f -executable 2>/dev/null | head -1)
            if [ -n "$BUILT_BINARY" ]; then
              echo "Found executable: $BUILT_BINARY, using it"
            fi
          fi
          
          if [ -z "$BUILT_BINARY" ] || [ ! -f "$BUILT_BINARY" ]; then
            echo "‚ùå Error: Built binary not found"
            echo "Build may have succeeded but binary was not produced"
            exit 1
          fi
          
          # Copy binary to app bundle
          APP_BINARY="HypoApp.app/Contents/MacOS/$BINARY_NAME"
          cp "$BUILT_BINARY" "$APP_BINARY"
          chmod +x "$APP_BINARY"
          echo "‚úÖ Binary copied successfully: $APP_BINARY"
          
          # Create or update Info.plist
          echo "Creating Info.plist..."
          # Extract version from tag (remove 'v' prefix if present)
          VERSION="${{ github.event.inputs.version || github.ref_name }}"
          VERSION="${VERSION#v}"  # Remove 'v' prefix if present
          # Create Info.plist using printf to avoid YAML lint issues with heredoc
          printf '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n    <key>CFBundleExecutable</key>\n    <string>HypoMenuBar</string>\n    <key>CFBundleIdentifier</key>\n    <string>com.hypo.clipboard</string>\n    <key>CFBundleName</key>\n    <string>Hypo</string>\n    <key>CFBundlePackageType</key>\n    <string>APPL</string>\n    <key>CFBundleVersion</key>\n    <string>5</string>\n    <key>CFBundleShortVersionString</key>\n    <string>%s</string>\n    <key>LSMinimumSystemVersion</key>\n    <string>13.0</string>\n    <key>LSUIElement</key>\n    <true/>\n    <key>NSHighResolutionCapable</key>\n    <true/>\n    <key>CFBundleIconFile</key>\n    <string>AppIcon</string>\n    <key>NSPrincipalClass</key>\n    <string>NSApplication</string>\n</dict>\n</plist>\n' "${VERSION}" > HypoApp.app/Contents/Info.plist
          
          # Generate icons if script exists
          echo "Generating icons..."
          if [ -f "../scripts/generate-icons.py" ]; then
            # Ensure Resources directory exists
            mkdir -p HypoApp.app/Contents/Resources
            # Run icon generation and capture output
            if python3 ../scripts/generate-icons.py 2>&1; then
              echo "‚úÖ Icons generated successfully"
              # Verify icon was created
              if [ -f "HypoApp.app/Contents/Resources/AppIcon.icns" ] || [ -d "HypoApp.app/Contents/Resources/AppIcon.iconset" ]; then
                echo "‚úÖ Icon file verified"
              else
                echo "‚ö†Ô∏è  Warning: Icon generation reported success but icon file not found"
              fi
            else
              echo "‚ùå Icon generation failed"
              echo "‚ö†Ô∏è  App will run without icon"
            fi
          else
            echo "‚ö†Ô∏è  Icon generation script not found at ../scripts/generate-icons.py"
            echo "‚ö†Ô∏è  App will run without icon"
          fi
          
          echo "macOS app build complete"
      
      - name: Sign macOS App
        working-directory: macos
        run: |
          echo "Signing macOS app with ad-hoc signature..."
          chmod +x ../scripts/sign-macos.sh
          ../scripts/sign-macos.sh HypoApp.app
          echo "‚úÖ App signed successfully"
      
      - name: Create macOS ZIP
        working-directory: macos
        run: |
          # Extract version from tag or input (not branch name for test branches)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            # For test branches, use a test version
            VERSION="v1.0.0-test"
          fi
          # Remove 'v' prefix if present and sanitize (replace slashes with dashes)
          VERSION="${VERSION#v}"
          SAFE_VERSION="${VERSION//\//-}"
          zip -r ../Hypo-${SAFE_VERSION}.zip HypoApp.app
      
      - name: Upload macOS App
        uses: actions/upload-artifact@v4
        with:
          name: macos-app
          path: Hypo-*.zip
          retention-days: 30

  create-release:
    name: Create Release
    needs: [build-android, build-macos]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for changelog
      
      - name: Get version from tag
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          elif [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" == refs/heads/test/* ]]; then
            # For test branches, check if current commit has a tag, otherwise use default
            COMMIT_TAG=$(git describe --tags --exact-match HEAD 2>/dev/null || echo "")
            if [ -n "$COMMIT_TAG" ]; then
              VERSION="$COMMIT_TAG"
            else
              # Default version for test branches (cleaner artifact names)
              VERSION="v1.0.0"
            fi
          else
            VERSION="${{ github.ref_name }}"
          fi
          # Remove 'v' prefix if present for tag
          TAG_NAME="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Version: $VERSION, Tag: $TAG_NAME"
      
      - name: Download Android Release APK
        uses: actions/download-artifact@v4
        with:
          name: android-release-apk
          path: ./artifacts
      
      - name: Download macOS App
        uses: actions/download-artifact@v4
        with:
          name: macos-app
          path: ./artifacts
      
      - name: Rename artifacts with version
        run: |
          cd artifacts
          TAG_NAME="${{ steps.version.outputs.tag }}"
          # Rename release APK (use hyphen separator: Hypo-1.0.2.apk)
          if [ -f "app-release.apk" ]; then
            mv app-release.apk Hypo-${TAG_NAME}.apk
          else
            echo "‚ùå Release APK not found!"
            exit 1
          fi
          # Rename macOS zip to use tag name (not branch name) if needed
          if [ -f "Hypo-"*.zip ]; then
            OLD_ZIP=$(ls Hypo-*.zip | head -1)
            EXPECTED_NAME="Hypo-${TAG_NAME}.zip"
            if [ "$OLD_ZIP" != "$EXPECTED_NAME" ]; then
              mv "$OLD_ZIP" "$EXPECTED_NAME"
            else
              echo "‚úì macOS ZIP already has correct name: $EXPECTED_NAME"
            fi
          fi
          ls -lh
      
      - name: Generate release notes
        id: release-notes
        run: |
          TAG_NAME="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"
          
          # Extract changelog if available
          if [ -f changelog.md ]; then
            # Try to extract section for this version (customize as needed)
            CHANGELOG_SECTION=$(awk "/## \[?$VERSION\]?/,/## \[?v[0-9]/" changelog.md | head -n -1 || echo "")
          fi
          
          # Auto-generate commit summary if no changelog section
          if [ -z "$CHANGELOG_SECTION" ]; then
            echo "üìù Generating commit summary..."
            
            # Find the previous tag (if any)
            PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            
            if [ -n "$PREV_TAG" ]; then
              # Get commits since last tag
              COMMIT_RANGE="${PREV_TAG}..HEAD"
            else
              # Get last 20 commits if no previous tag
              COMMIT_RANGE="HEAD~20..HEAD"
            fi
            
            # Generate categorized commit summary
            COMMIT_SUMMARY=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | \
              awk '
              BEGIN {
                feat_count = 0
                fix_count = 0
                docs_count = 0
                ci_count = 0
                refactor_count = 0
                perf_count = 0
                security_count = 0
                other_count = 0
                
                feat_items = ""
                fix_items = ""
                docs_items = ""
                ci_items = ""
                refactor_items = ""
                perf_items = ""
                security_items = ""
                other_items = ""
              }
              {
                # Parse conventional commit format: type(scope): message
                if (match($0, /^([a-z]+)(\([^)]+\))?:/, arr)) {
                  type = arr[1]
                  # Extract message (everything after ": ")
                  if (match($0, /^[^:]+: (.+)$/, msg_arr)) {
                    message = msg_arr[1]
                  } else {
                    message = $0
                  }
                  
                  # Clean up message (remove common prefixes, capitalize first letter)
                  gsub(/^[a-z]/, toupper(substr(message, 1, 1)), message)
                  
                  if (type == "feat") {
                    feat_count++
                    feat_items = feat_items "- " message "\n"
                  } else if (type == "fix") {
                    fix_count++
                    fix_items = fix_items "- " message "\n"
                  } else if (type == "docs") {
                    docs_count++
                    docs_items = docs_items "- " message "\n"
                  } else if (type == "ci") {
                    ci_count++
                    ci_items = ci_items "- " message "\n"
                  } else if (type == "refactor") {
                    refactor_count++
                    refactor_items = refactor_items "- " message "\n"
                  } else if (type == "perf") {
                    perf_count++
                    perf_items = perf_items "- " message "\n"
                  } else if (type == "security") {
                    security_count++
                    security_items = security_items "- " message "\n"
                  } else {
                    other_count++
                    other_items = other_items "- " message "\n"
                  }
                } else {
                  # Non-conventional commit
                  other_count++
                  other_items = other_items "- " $0 "\n"
                }
              }
              END {
                if (feat_count > 0) {
                  print "### ‚ú® Features\n"
                  print feat_items
                }
                if (fix_count > 0) {
                  print "### üêõ Bug Fixes\n"
                  print fix_items
                }
                if (security_count > 0) {
                  print "### üîí Security\n"
                  print security_items
                }
                if (perf_count > 0) {
                  print "### ‚ö° Performance\n"
                  print perf_items
                }
                if (refactor_count > 0) {
                  print "### ‚ôªÔ∏è Refactoring\n"
                  print refactor_items
                }
                if (docs_count > 0) {
                  print "### üìö Documentation\n"
                  print docs_items
                }
                if (ci_count > 0) {
                  print "### üîß CI/CD\n"
                  print ci_items
                }
                if (other_count > 0) {
                  print "### üì¶ Other Changes\n"
                  print other_items
                }
              }')
            
            if [ -n "$COMMIT_SUMMARY" ]; then
              CHANGELOG_SECTION="$COMMIT_SUMMARY"
            else
              CHANGELOG_SECTION="No significant changes detected."
            fi
          fi
          
          # Create release notes
          cat > release-notes.md << EOF
          # Release $VERSION
          
          ## Downloads
          
          - **Android**: \`Hypo-${TAG_NAME}.apk\`
          - **macOS**: \`Hypo-${TAG_NAME}.zip\`
          
          ## Installation
          
          See [INSTALLATION.md](docs/INSTALLATION.md) for detailed installation instructions.
          
          ### macOS First Launch
          
          **Important**: After downloading and extracting the macOS app, you may see a "damaged" error. This is due to macOS quarantine (see explanation below).
          
          **Quick Fix:**
          \`\`\`bash
          # Remove quarantine attribute
          xattr -d com.apple.quarantine HypoApp.app
          
          # Then launch by right-clicking ‚Üí Open ‚Üí Open
          \`\`\`
          
          You'll see a "cannot be verified" warning - this is normal for ad-hoc signed apps. Click **Open** to proceed.
          
          **Why this happens**: macOS automatically adds a quarantine attribute to files downloaded from the internet (via Safari, Chrome, curl, etc.). This is a security feature called Gatekeeper. The attribute is stored as an extended attribute (`com.apple.quarantine`) and contains metadata about where the file came from.
          
          **Important distinction**: Our app IS signed (ad-hoc signature), but macOS treats ad-hoc signatures differently:
          - **Ad-hoc signed + quarantined** ‚Üí Shows "damaged" error (ad-hoc is not a trusted developer signature)
          - **Developer ID signed + quarantined + not notarized** ‚Üí Shows "cannot be verified" warning
          - **Developer ID signed + notarized** ‚Üí Opens normally
          
          **Why other projects don't show "damaged"**: They use Developer ID signatures (\$99/year Apple Developer Program) and notarize their apps. This makes macOS trust them automatically. Since we use free ad-hoc signing (no \$99/year Apple Developer account), macOS considers it "untrusted" when quarantined. Removing the quarantine attribute allows the app to run, but you'll still need to bypass the "cannot be verified" warning by right-clicking ‚Üí Open.
          
          ## Changes
          
          ${CHANGELOG_SECTION}
          
          ## Checksums
          
          \`\`\`
          SHA256 checksums:
          \`\`\`
          EOF
          
          # Add checksums
          cd artifacts
          for file in *.apk *.zip; do
            if [ -f "$file" ]; then
              SHA256=$(sha256sum "$file" | awk '{print $1}')
              echo "  $SHA256  $file" >> ../release-notes.md
            fi
          done
          cd ..
          
          echo "notes_path=release-notes.md" >> $GITHUB_OUTPUT
      
      - name: Delete existing release if present
        if: github.event_name == 'workflow_dispatch' && !contains(github.ref, 'refs/heads/test/')
        run: |
          TAG_NAME="${{ steps.version.outputs.tag }}"
          if gh release view "$TAG_NAME" &>/dev/null; then
            echo "Deleting existing release $TAG_NAME..."
            gh release delete "$TAG_NAME" --yes || true
          fi
        continue-on-error: true
      
      - name: Delete existing tag if present
        if: github.event_name == 'workflow_dispatch' && !contains(github.ref, 'refs/heads/test/')
        run: |
          TAG_NAME="${{ steps.version.outputs.tag }}"
          if git rev-parse "$TAG_NAME" &>/dev/null; then
            echo "Deleting existing tag $TAG_NAME..."
            git tag -d "$TAG_NAME" || true
            git push origin ":refs/tags/$TAG_NAME" || true
          fi
        continue-on-error: true
      
      - name: Create Git Tag (if workflow_dispatch and not test branch)
        if: github.event_name == 'workflow_dispatch' && !contains(github.ref, 'refs/heads/test/')
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG_NAME="${{ steps.version.outputs.tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG_NAME" -m "Release $VERSION"
          git push origin "$TAG_NAME"
      
      - name: Create Release
        if: github.event_name != 'push' || !contains(github.ref, 'refs/heads/test/')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Release ${{ steps.version.outputs.version }}
          body_path: ${{ steps.release-notes.outputs.notes_path }}
          files: |
            artifacts/Hypo-*.apk
            artifacts/Hypo-*.zip
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') || contains(steps.version.outputs.version, 'beta') || contains(steps.version.outputs.version, 'alpha') }}
          generate_release_notes: true
