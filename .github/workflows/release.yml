name: Release

on:
  push:
    tags:
      - 'v*'  # Triggers on tags like v0.2.2, v1.0.0, etc.
    branches:
      - 'test/**'  # Also trigger on test branches for debugging
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.2.2)'
        required: true
        type: string

jobs:
  build-android:
    name: Build Android APK
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'
      
      - name: Cache Android SDK
        uses: actions/cache@v4
        with:
          path: |
            ~/.android
          key: ${{ runner.os }}-android-sdk-${{ hashFiles('android/**/*.gradle*', 'android/**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-android-sdk-
      
      - name: Setup Android SDK
        uses: android-actions/setup-android@v3
      
      - name: Accept Android SDK Licenses
        run: |
          # Accept all Android SDK licenses
          mkdir -p "$ANDROID_HOME/licenses"
          echo "24333f8a63b6825ea9c5514f83c2829b004d1fee" > "$ANDROID_HOME/licenses/android-sdk-license"
          echo "84831b9409646a918e30573bab4c9c91346d8abd" > "$ANDROID_HOME/licenses/android-sdk-preview-license"
          echo "601085b94cd77f0b54ff86406957099ebe79c4d6" > "$ANDROID_HOME/licenses/android-googletv-license"
          echo "33b6a2b64607a11ce79713110d54f32d" > "$ANDROID_HOME/licenses/android-sdk-arm-dbt-license"
          echo "d975f751698a77b662f1254ddbeed3901e976f5a" > "$ANDROID_HOME/licenses/intel-android-extra-license"
          echo "8403addf88ab4874007e1c1e80a0025de956b318" > "$ANDROID_HOME/licenses/google-gdk-license"
          echo "601085b94cd77f0b54ff86406957099ebe79c4d6" > "$ANDROID_HOME/licenses/mips-android-sysimage-license"
      
      - name: Grant execute permission for gradlew
        run: chmod +x android/gradlew
      
      - name: Build Release APK
        id: build-apk
        working-directory: android
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          # Increase Gradle JVM memory for faster builds
          GRADLE_OPTS: -Xmx4096m -Dfile.encoding=UTF-8
        run: |
          echo "ðŸš€ Starting Android build at $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          START_TIME=$(date +%s)
          ./gradlew assembleRelease --stacktrace --build-cache
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "âœ… Build completed in ${DURATION} seconds"
          echo "duration=${DURATION}" >> $GITHUB_OUTPUT
      
      - name: Build time summary
        if: always()
        run: |
          if [ -n "${{ steps.build-apk.outputs.duration }}" ]; then
            echo "### â±ï¸ Android Build Time" >> $GITHUB_STEP_SUMMARY
            echo "Build completed in **${{ steps.build-apk.outputs.duration }} seconds**" >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Upload Release APK
        uses: actions/upload-artifact@v4
        with:
          name: android-release-apk
          path: android/app/build/outputs/apk/release/app-release.apk
          # Optimize retention: shorter for test branches, longer for releases
          retention-days: ${{ contains(github.ref, 'refs/heads/test/') && '7' || '30' }}
          compression-level: 6

  build-macos:
    name: Build macOS App
    runs-on: macos-14
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python (for icon generation)
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      
      - name: Install Python dependencies
        run: pip install Pillow
      
      - name: Build macOS App
        working-directory: macos
        run: |
          set -e
          BINARY_NAME="HypoMenuBar"
          
          # Build the Swift package
          echo "Building Swift package..."
          swift build -c release
          
          # Create app bundle structure if it doesn't exist
          if [ ! -d "HypoApp.app" ]; then
            echo "Creating app bundle structure..."
            mkdir -p HypoApp.app/Contents/MacOS
            mkdir -p HypoApp.app/Contents/Resources
          fi
          
          # Find the built binary (product name is HypoMenuBar, target is HypoMenuBarApp)
          echo "Looking for built binary..."
          BUILT_BINARY=""
          
          # First, try the expected location (product name)
          if [ -f ".build/release/$BINARY_NAME" ]; then
            BUILT_BINARY=".build/release/$BINARY_NAME"
            echo "Found: $BUILT_BINARY"
          # Fallback: try target name
          elif [ -f ".build/release/HypoMenuBarApp" ]; then
            BUILT_BINARY=".build/release/HypoMenuBarApp"
            echo "Found: $BUILT_BINARY"
          # Fallback: search for any executable with MenuBar in name
          else
            BUILT_BINARY=$(find .build/release -name "*MenuBar*" -type f -executable 2>/dev/null | head -1)
            if [ -n "$BUILT_BINARY" ]; then
              echo "Found: $BUILT_BINARY"
            fi
          fi
          
          # Last resort: find any executable in release directory
          if [ -z "$BUILT_BINARY" ]; then
            echo "Error: Binary not found. Searching for any executables..."
            echo "Available files in .build/release:"
            find .build/release -type f 2>/dev/null | head -10 || echo "No .build/release directory found"
            echo "Available executables in .build:"
            find .build -type f -executable 2>/dev/null | head -10 || echo "No executables found"
            BUILT_BINARY=$(find .build/release -type f -executable 2>/dev/null | head -1)
            if [ -n "$BUILT_BINARY" ]; then
              echo "Found executable: $BUILT_BINARY, using it"
            fi
          fi
          
          if [ -z "$BUILT_BINARY" ] || [ ! -f "$BUILT_BINARY" ]; then
            echo "âŒ Error: Built binary not found"
            echo "Build may have succeeded but binary was not produced"
            exit 1
          fi
          
          # Copy binary to app bundle
          APP_BINARY="HypoApp.app/Contents/MacOS/$BINARY_NAME"
          cp "$BUILT_BINARY" "$APP_BINARY"
          chmod +x "$APP_BINARY"
          echo "âœ… Binary copied successfully: $APP_BINARY"
          
          # Create or update Info.plist
          echo "Creating Info.plist..."
          # Extract version from tag (remove 'v' prefix if present)
          VERSION="${{ github.event.inputs.version || github.ref_name }}"
          VERSION="${VERSION#v}"  # Remove 'v' prefix if present
          # Create Info.plist using printf to avoid YAML lint issues with heredoc
          # Include NSServices for "Copy to Hypo" context menu feature
          # Extract build number from version (e.g., 1.0.7 -> 7)
          BUILD_NUMBER=$(echo "${VERSION}" | awk -F. '{print $3}')
          if [ -z "$BUILD_NUMBER" ]; then
            BUILD_NUMBER="1"  # Fallback if version format is unexpected
          fi
          printf '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n    <key>CFBundleExecutable</key>\n    <string>HypoMenuBar</string>\n    <key>CFBundleIdentifier</key>\n    <string>com.hypo.clipboard</string>\n    <key>CFBundleName</key>\n    <string>Hypo</string>\n    <key>CFBundlePackageType</key>\n    <string>APPL</string>\n    <key>CFBundleVersion</key>\n    <string>%s</string>\n    <key>CFBundleShortVersionString</key>\n    <string>%s</string>\n    <key>LSMinimumSystemVersion</key>\n    <string>13.0</string>\n    <key>LSUIElement</key>\n    <true/>\n    <key>NSHighResolutionCapable</key>\n    <true/>\n    <key>CFBundleIconFile</key>\n    <string>AppIcon</string>\n    <key>NSPrincipalClass</key>\n    <string>NSApplication</string>\n    <key>NSServices</key>\n    <array>\n        <dict>\n            <key>NSMenuItem</key>\n            <dict>\n                <key>default</key>\n                <string>Copy to Hypo</string>\n            </dict>\n            <key>NSMessage</key>\n            <string>copyToHypo</string>\n            <key>NSPortName</key>\n            <string>com.hypo.clipboard</string>\n            <key>NSSendTypes</key>\n            <array>\n                <string>NSStringPboardType</string>\n                <string>public.plain-text</string>\n            </array>\n        </dict>\n    </array>\n</dict>\n</plist>\n' "${BUILD_NUMBER}" "${VERSION}" > HypoApp.app/Contents/Info.plist
          
          # Generate icons if script exists
          echo "Generating icons..."
          if [ -f "../scripts/generate-icons.py" ]; then
            # Ensure Resources directory exists
            mkdir -p HypoApp.app/Contents/Resources
            # Run icon generation and capture output
            if python3 ../scripts/generate-icons.py 2>&1; then
              echo "âœ… Icons generated successfully"
              # Verify icon was created
              if [ -f "HypoApp.app/Contents/Resources/AppIcon.icns" ] || [ -d "HypoApp.app/Contents/Resources/AppIcon.iconset" ]; then
                echo "âœ… Icon file verified"
              else
                echo "âš ï¸  Warning: Icon generation reported success but icon file not found"
              fi
            else
              echo "âŒ Icon generation failed"
              echo "âš ï¸  App will run without icon"
            fi
          else
            echo "âš ï¸  Icon generation script not found at ../scripts/generate-icons.py"
            echo "âš ï¸  App will run without icon"
          fi
          
          echo "macOS app build complete"
      
      - name: Sign macOS App
        working-directory: macos
        run: |
          echo "Signing macOS app with ad-hoc signature..."
          chmod +x ../scripts/sign-macos.sh
          ../scripts/sign-macos.sh HypoApp.app
          echo "âœ… App signed successfully"
      
      - name: Create macOS ZIP
        working-directory: macos
        run: |
          # Extract version from tag or input (not branch name for test branches)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            # For test branches, use a test version
            VERSION="v1.0.0-test"
          fi
          # Remove 'v' prefix if present and sanitize (replace slashes with dashes)
          VERSION="${VERSION#v}"
          SAFE_VERSION="${VERSION//\//-}"
          # Append -release for consistency with local build scripts
          zip -r ../Hypo-${SAFE_VERSION}-release.zip HypoApp.app
      
      - name: Upload macOS App
        uses: actions/upload-artifact@v4
        with:
          name: macos-app
          path: Hypo-*.zip
          retention-days: 30

  create-release:
    name: Create Release
    needs: [build-android, build-macos]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for changelog
      
      - name: Get version from tag
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          elif [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" == refs/heads/test/* ]]; then
            # For test branches, check if current commit has a tag, otherwise use default
            COMMIT_TAG=$(git describe --tags --exact-match HEAD 2>/dev/null || echo "")
            if [ -n "$COMMIT_TAG" ]; then
              VERSION="$COMMIT_TAG"
            else
              # Default version for test branches (cleaner artifact names)
              VERSION="v1.0.0"
            fi
          else
            VERSION="${{ github.ref_name }}"
          fi
          # Remove 'v' prefix if present for tag
          TAG_NAME="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Version: $VERSION, Tag: $TAG_NAME"
      
      - name: Download Android Release APK
        uses: actions/download-artifact@v4
        with:
          name: android-release-apk
          path: ./artifacts
      
      - name: Download macOS App
        uses: actions/download-artifact@v4
        with:
          name: macos-app
          path: ./artifacts
      
      - name: Rename artifacts with version
        run: |
          cd artifacts
          TAG_NAME="${{ steps.version.outputs.tag }}"
          # Rename release APK (append -release for consistency with local build scripts)
          if [ -f "app-release.apk" ]; then
            mv app-release.apk Hypo-${TAG_NAME}-release.apk
          else
            echo "âŒ Release APK not found!"
            exit 1
          fi
          # Rename macOS zip to use tag name with -release suffix (for consistency with local build scripts)
          if [ -f "Hypo-"*.zip ]; then
            OLD_ZIP=$(ls Hypo-*.zip | head -1)
            EXPECTED_NAME="Hypo-${TAG_NAME}-release.zip"
            if [ "$OLD_ZIP" != "$EXPECTED_NAME" ]; then
              mv "$OLD_ZIP" "$EXPECTED_NAME"
            else
              echo "âœ“ macOS ZIP already has correct name: $EXPECTED_NAME"
            fi
          fi
          ls -lh
      
      - name: Generate release notes
        id: release-notes
        run: |
          TAG_NAME="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"
          
          # Extract changelog if available
          if [ -f changelog.md ]; then
            # Try to extract section for this version (customize as needed)
            CHANGELOG_SECTION=$(awk "/## \[?$VERSION\]?/,/## \[?v[0-9]/" changelog.md | head -n -1 || echo "")
          fi
          
          # Auto-generate commit summary if no changelog section
          if [ -z "$CHANGELOG_SECTION" ]; then
            echo "ðŸ“ Generating commit summary..."
            
            # Find the previous tag (if any)
            # Try to find the most recent tag before current HEAD
            PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || git tag --sort=-version:refname | head -1 || echo "")
            
            if [ -n "$PREV_TAG" ] && [ "$PREV_TAG" != "$VERSION" ]; then
              # Get commits since last tag
              COMMIT_RANGE="${PREV_TAG}..HEAD"
              echo "ðŸ“ Comparing commits from ${PREV_TAG} to HEAD"
            else
              # Get last 30 commits if no previous tag or same tag
              COMMIT_RANGE="HEAD~30..HEAD"
              echo "ðŸ“ Using last 30 commits (no previous tag found)"
            fi
            
            # Generate categorized commit summary
            COMMIT_SUMMARY=$(git log $COMMIT_RANGE --pretty=format:"%s" --no-merges | \
              awk '
              BEGIN {
                feat_count = 0
                fix_count = 0
                docs_count = 0
                ci_count = 0
                refactor_count = 0
                perf_count = 0
                security_count = 0
                other_count = 0
                
                feat_items = ""
                fix_items = ""
                docs_items = ""
                ci_items = ""
                refactor_items = ""
                perf_items = ""
                security_items = ""
                other_items = ""
              }
              {
                # Parse conventional commit format: type(scope): message
                if (match($0, /^([a-z]+)(\([^)]+\))?:/, arr)) {
                  type = arr[1]
                  # Extract message (everything after ": ")
                  if (match($0, /^[^:]+: (.+)$/, msg_arr)) {
                    message = msg_arr[1]
                  } else {
                    message = $0
                  }
                  
                  # Clean up message (remove common prefixes, capitalize first letter)
                  gsub(/^[a-z]/, toupper(substr(message, 1, 1)), message)
                  
                  if (type == "feat") {
                    feat_count++
                    feat_items = feat_items "- " message "\n"
                  } else if (type == "fix") {
                    fix_count++
                    fix_items = fix_items "- " message "\n"
                  } else if (type == "docs") {
                    docs_count++
                    docs_items = docs_items "- " message "\n"
                  } else if (type == "ci") {
                    ci_count++
                    ci_items = ci_items "- " message "\n"
                  } else if (type == "refactor") {
                    refactor_count++
                    refactor_items = refactor_items "- " message "\n"
                  } else if (type == "perf") {
                    perf_count++
                    perf_items = perf_items "- " message "\n"
                  } else if (type == "security") {
                    security_count++
                    security_items = security_items "- " message "\n"
                  } else {
                    other_count++
                    other_items = other_items "- " message "\n"
                  }
                } else {
                  # Non-conventional commit
                  other_count++
                  other_items = other_items "- " $0 "\n"
                }
              }
              END {
                if (feat_count > 0) {
                  print "### âœ¨ Features\n"
                  print feat_items
                }
                if (fix_count > 0) {
                  print "### ðŸ› Bug Fixes\n"
                  print fix_items
                }
                if (security_count > 0) {
                  print "### ðŸ”’ Security\n"
                  print security_items
                }
                if (perf_count > 0) {
                  print "### âš¡ Performance\n"
                  print perf_items
                }
                if (refactor_count > 0) {
                  print "### â™»ï¸ Refactoring\n"
                  print refactor_items
                }
                if (docs_count > 0) {
                  print "### ðŸ“š Documentation\n"
                  print docs_items
                }
                if (ci_count > 0) {
                  print "### ðŸ”§ CI/CD\n"
                  print ci_items
                }
                if (other_count > 0) {
                  print "### ðŸ“¦ Other Changes\n"
                  print other_items
                }
              }')
            
            if [ -n "$COMMIT_SUMMARY" ]; then
              CHANGELOG_SECTION="$COMMIT_SUMMARY"
            else
              CHANGELOG_SECTION="### ðŸ“ Changes\n\nNo significant changes detected in this release."
            fi
          fi
          
          # Create release notes
          cat > release-notes.md << EOF
          # Release $VERSION
          
          ## ðŸ“¦ Downloads
          
          - **Android**: [\`Hypo-${TAG_NAME}-release.apk\`](Hypo-${TAG_NAME}-release.apk)
          - **macOS**: [\`Hypo-${TAG_NAME}-release.zip\`](Hypo-${TAG_NAME}-release.zip)
          
          ## ðŸ“– Installation
          
          For detailed installation instructions, see the [User Guide](docs/USER_GUIDE.md#installation).
          
          ### ðŸŽ macOS Installation
          
          1. Download and extract \`Hypo-${TAG_NAME}-release.zip\`
          2. **Important**: After extracting, you may see a "damaged" error when trying to open the app. This is due to macOS quarantine.
          
          **Quick Fix:**
          \`\`\`bash
          # Remove quarantine attribute
          xattr -d com.apple.quarantine HypoApp.app
          
          # Then launch by right-clicking â†’ Open â†’ Open
          \`\`\`
          
          You'll see a "cannot be verified" warning - this is normal for ad-hoc signed apps. Click **Open** to proceed.
          
          **Why this happens**: macOS automatically adds a quarantine attribute to files downloaded from the internet. This is a security feature called Gatekeeper. Our app uses ad-hoc signing (free, no Apple Developer account required), so macOS requires manual approval on first launch.
          
          ### ðŸ¤– Android Installation
          
          1. Download \`Hypo-${TAG_NAME}-release.apk\` to your Android device
          2. Open the APK file (you may need to enable "Install from unknown sources" in Settings)
          3. Follow the on-screen installation prompts
          4. Grant necessary permissions when prompted (clipboard access, network access, etc.)
          
          **Note**: On MIUI/HyperOS devices, you may need to enable additional permissions in Settings â†’ Apps â†’ Hypo â†’ Other permissions.
          
          ## ðŸ†• What's New
          
          ${CHANGELOG_SECTION}
          
          ## ðŸ” Security & Verification
          
          ### SHA256 Checksums
          
          Verify the integrity of downloaded files using these checksums:
          
          \`\`\`
          SHA256 checksums:
          \`\`\`
          EOF
          
          # Add checksums
          cd artifacts
          for file in *.apk *.zip; do
            if [ -f "$file" ]; then
              SHA256=$(sha256sum "$file" | awk '{print $1}')
              echo "  \`$SHA256\`  \`$file\`" >> ../release-notes.md
            fi
          done
          cd ..
          
          echo "notes_path=release-notes.md" >> $GITHUB_OUTPUT
      
      - name: Delete existing release if present
        if: github.event_name == 'workflow_dispatch' && !contains(github.ref, 'refs/heads/test/')
        run: |
          TAG_NAME="${{ steps.version.outputs.tag }}"
          if gh release view "$TAG_NAME" &>/dev/null; then
            echo "Deleting existing release $TAG_NAME..."
            gh release delete "$TAG_NAME" --yes || true
          fi
        continue-on-error: true
      
      - name: Delete existing tag if present
        if: github.event_name == 'workflow_dispatch' && !contains(github.ref, 'refs/heads/test/')
        run: |
          TAG_NAME="${{ steps.version.outputs.tag }}"
          if git rev-parse "$TAG_NAME" &>/dev/null; then
            echo "Deleting existing tag $TAG_NAME..."
            git tag -d "$TAG_NAME" || true
            git push origin ":refs/tags/$TAG_NAME" || true
          fi
        continue-on-error: true
      
      - name: Create Git Tag (if workflow_dispatch and not test branch)
        if: github.event_name == 'workflow_dispatch' && !contains(github.ref, 'refs/heads/test/')
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG_NAME="${{ steps.version.outputs.tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG_NAME" -m "Release $VERSION"
          git push origin "$TAG_NAME"
      
      - name: Create Release
        if: github.event_name != 'push' || !contains(github.ref, 'refs/heads/test/')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Release ${{ steps.version.outputs.version }}
          body_path: ${{ steps.release-notes.outputs.notes_path }}
          files: |
            artifacts/Hypo-*-release.apk
            artifacts/Hypo-*-release.zip
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') || contains(steps.version.outputs.version, 'beta') || contains(steps.version.outputs.version, 'alpha') }}
          generate_release_notes: true
